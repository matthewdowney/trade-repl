// Compiled by ClojureScript 1.10.238 {}
goog.provide('trade_repl.core');
goog.require('cljs.core');
goog.require('reagent.core');
goog.require('trade_repl.macros');
goog.require('trade_repl.editor');
goog.require('trade_repl.display');
goog.require('trade_repl.dsl');
goog.require('goog.crypt.base64');
goog.require('clojure.string');
/**
 * We allow linking to scratchpads with a content=<base 64 encoded :input-text>
 *   query param, so, on the first page load, check for the query param and decode
 *   its text if it's present.
 */
trade_repl.core._QMARK_linked_content = (function trade_repl$core$_QMARK_linked_content(){
var G__26838 = [cljs.core.str.cljs$core$IFn$_invoke$arity$1(window.location)].join('');
var G__26838__$1 = (((G__26838 == null))?null:clojure.string.split.call(null,G__26838,/\?/));
var G__26838__$2 = (((G__26838__$1 == null))?null:cljs.core.last.call(null,G__26838__$1));
var G__26838__$3 = (((G__26838__$2 == null))?null:(function (){var it = G__26838__$2;
return cljs.core.re_matches.call(null,/content=(.*)#*/,it);
})());
var G__26838__$4 = (((G__26838__$3 == null))?null:cljs.core.second.call(null,G__26838__$3));
var G__26838__$5 = (((G__26838__$4 == null))?null:clojure.string.split.call(null,G__26838__$4,/#/));
var G__26838__$6 = (((G__26838__$5 == null))?null:cljs.core.first.call(null,G__26838__$5));
if((G__26838__$6 == null)){
return null;
} else {
return goog.crypt.base64.decodeString(G__26838__$6);
}
});
if(typeof trade_repl.core.editor_text !== 'undefined'){
} else {
trade_repl.core.editor_text = reagent.core.atom.call(null,(function (){var or__3922__auto__ = trade_repl.core._QMARK_linked_content.call(null);
if(cljs.core.truth_(or__3922__auto__)){
return or__3922__auto__;
} else {
return ["# Trade Scratchpad\r\n\r\nThis is a client side **scratchpad**, document generator, and lightweight modeling tool\r\nthat leverages small ClojureScript DSLs to render dynamic content (hosted on \r\n[GitHub](https://github.com/matthewdowney/trade-repl)).\r\n\r\nI use it for brainstorming and  explaining trades with **spot products, futures, and \r\noptions**. This document serves as a tutorial of the capabilities this scratchpad offers\r\non top of standard markdown.\r\n\r\nTo get the ball rolling, **I'll first include two examples** of the type of things you \r\ncan model, after which the DSL is explained in detail.\r\n\r\n> You can (and should!) play around with the examples by modifying the source (on the \r\n  left).\r\n\r\n---\r\n\r\n## Contents\r\n\r\n- Examples\r\n  - Triangular Arbitrage\r\n  - PNL Curve for a Convoluted Trade\r\n- Expressions\r\n- Rendering\r\n- Variable Exposures\r\n- Plotting Variable Exposures\r\n- Plotting Options Payoff\r\n- Custom Plots\r\n\r\n---\r\n\r\n## Examples\r\n\r\n### Triangular Arbitrage\r\n**Arbitrage** \u2014 the simplest trade of all:\r\n~~~\r\n(pos\r\n ;; Use `buy` and `sell` to represent position changes\r\n ;; from trades with spot products\r\n (buy 1 :btc-usd 8000)\r\n (buy 20 :eth-btc 0.05)\r\n \r\n ;; You can also write the exposures manually, with an optional\r\n ;; \"Desc\"ription attribute\r\n {:eth -20, :usd +8100, \"Desc\" \"Sell eth for usd\"})\r\n~~~\r\n\r\n### PNL Curve for a Convoluted Trade\r\n\r\nFor a more advanced example, let's model shorting 50 ETH/USD while **buying calls** on \r\nBTC/USD, with the assumption that **ETH will gain or lose at 1.3x the rate the BTC \r\ngains or loses**. Tab through the \"Breakdown\" and \"Total PNL\" graphs for this \r\nnonsensical and complex trade:\r\n\r\n> This \"trade\" is designed to be more convoluted than it is realistic, to show that\r\n  while this scratchpad is designed to prioritize a **tight mental feedback loop** over\r\n  capabilities (it's not Excel), dipping in to the DSL allows a certain level of \r\n  creativility.\r\n\r\n~~~\r\n(let [init-prices {:btc 7900 :eth 95}\r\n      \r\n      ;; Model the USD value of a hypothetical ETH positions that gains/loses\r\n      ;; at some multiplier of the btc-usd price change\r\n      eth-usd-pos \r\n      {:usd (fn [{:keys [btc-usd] :as context}]\r\n              (let [og-price (:btc init-prices)\r\n                    change (/ (- og-price btc-usd) og-price)\r\n                    expected-eth-change (* change 1.3)]\r\n                (* 20 expected-eth-change (:eth init-prices))))\r\n       \"Desc\" \"Short 20 ETH @ $95\"}]\r\n  \r\n  ;; Graph a range of possible btc-usd price scenarios\r\n  (pnl-range \r\n   [:btc-usd (range 4500 10500 50)]\r\n   eth-usd-pos\r\n   (call :btc-usd {:price 150 :strike 8000}))))\r\n~~~\r\n\r\nFrom the \"Total PNL\" tab, we can surmise that the trade is profitable when BTC/USD is \r\npriced below $7,400 or above $8,250, and that the PNL increases more rapidly as the \r\nprice rises than it does as the price falls.\r\n\r\n## Expressions\r\n\r\nExpressions written between two lines of `~~~` are **evaluated** and displayed as text.\r\n\r\nAll [ClojureScript](https://clojurescript.org/) expressions are valid and all of \r\nthe non-markdown functionality works by **combining expressions**.\r\n\r\n~~~\r\n;; Let's evaluate 3 expressions in a list\r\n(list\r\n (+ 1 1)   \r\n (* 5 5 5)\r\n ;; The first 15 powers of 2\r\n (let [n 15]\r\n   (reductions * (repeat n 2))))\r\n~~~\r\n\r\n> Careful with infinite sequences though. `(repeat 2)`, for example, would **crash the \r\n  browser**.\r\n\r\n\r\nThe embedded DSL has built-in expressions to represent the **position changes** \r\nresulting from trades with normal contracts as well as options.\r\n~~~\r\n(buy 1 :eur-usd 1.20)\r\n~~~\r\n\r\n~~~\r\n(put :btc-usd {:price 150 :strike 8000})\r\n~~~\r\n\r\nSometimes the evaluated expressions are useful or interesting in and of themselves, but\r\noften (as in the case of the `put` option) the expressions are just **building blocks**.\r\n\r\n## Rendering\r\n\r\nYou can also write expressions that evaluate to \r\n[hiccup](https://github.com/weavejester/hiccup), which is an alternative HTML \r\nrepresentation. In order to _render_ the result instead of displaying the hiccup\r\ndata, wrap the result in a call to `render`. \r\n\r\n~~~\r\n;; Define a rendering function\r\n(defn put-in-a-box [x]\r\n  (render \r\n   [:div {:style {:width \"75%\", :margin-left \"auto\", :margin-right \"auto\", \r\n                  :border \"3px solid steelblue\", :padding \"35px\"}}\r\n    [:center x]]))\r\n~~~\r\n\r\n~~~\r\n(put-in-a-box \"Hello world, I'm a custom rendered piece of HTML.\")\r\n~~~\r\n\r\n**The built-in syntax for visualizing positions & exposures work by building hiccup HTML\r\nfrom the input expressions and rendering it.**\r\n\r\nYou can also nest calls to `render`, so the following is valid:\r\n~~~\r\n(put-in-a-box \r\n (pos \r\n  (buy 1 :btc-usd 15)))\r\n~~~\r\n\r\n## Variable Exposures\r\n\r\nWe'll use the `build-context` expression for trades that need more context to analyze, \r\nwhere we might want to see **results across a range** of possible context values.\r\n\r\nFor example, BitMEX offers an XBTUSD contract worth 1 USD of BTC that quotes in dollar \r\nprices, which means your position can only be calculated with regard to the current \r\nBTCUSD price.\r\n\r\nLet's say you're long $8,000 USD worth of BTC, at an entry price of $8,000. Your \r\nposition size is 8000 USD _divided by_ the current BTC/USD price and your total \r\nexposure is your position size plus any PNL. Here's how your BTC exposure looks at a \r\nprice of $20,000. \r\n~~~\r\n;; (1) We `def` the position to save it for later\r\n(def btc-position\r\n  {:btc (fn [all-prices] (/ 8000 (get all-prices :btc-usd))), \r\n   :usd -8000,\r\n   \"Desc\" \"$8,000 worth of BTC\"})\r\n\r\n;; (2) Build our positions table, but include the btc-usd price for context\r\n(put-in-a-box\r\n [:div \r\n  (pos (build-context {:btc-usd 20000}) btc-position)\r\n  [:i \"Just considering the size of the BTC position, not looking at PNL.\"]])\r\n~~~\r\n\r\nNow, in a simple table, there's really no need to use `build-context` instead of a `let`\r\nstatement, but it comes in handy when it's time to turn a static table into a **dynamic\r\nplot**.\r\n\r\n## Plotting Variable Exposures\r\n\r\nLet's model shorting the XBTUSD contract \u2014 this time including the PNL \u2014 and \r\nsimultaneously going long on a spot exchange:\r\n~~~\r\n(pnl-range\r\n [:btc-usd (range 7000 9000 10)]\r\n (buy 1 :btc-usd 8000)\r\n \r\n ;; Alternatively, we could use the built-in syntax for \r\n ;; inverse positions: (inverse -8000 :btc-usd 8000) :) \r\n {:btc (fn [prices] (/ -8000 (get prices :btc-usd)))\r\n  :usd (fn [prices]\r\n         (let [initial 8000\r\n               pnl (* (/ -8000 (get prices :btc-usd))\r\n                      (- (get prices :btc-usd) 8000))] \r\n           (+ initial pnl)))\r\n  \"Desc\" \"XBTUSD Short\"}))\r\n~~~\r\n\r\nThat's fun! Obviously had we shorted on another spot exchange, we'd just have a flat\r\nline at 0 (or whatever the difference in price between our short and long was). By\r\ntabbing to the \"Breakdown\", we can see that there is a slight convexity to the XBTUSD\r\nshort that sums with the linear spot position to create the element of **positive \r\noptionality** that we see in the \"Total PNL\" tab.\r\n\r\n> I wrote out the calculations for the exposure & PNL to demonstrate modeling positions\r\n  that require arbitrary logic, but for this specific case **the DSL includes an \r\n  `inverse` expression**.\r\n\r\n## Plotting Options Payoff\r\n\r\nLet's model a **call overwrite** trade \u2014 here we can see that the call option premium \r\nincreases the profitability of the long position until the option's strike price, at \r\nwhich point it imposes a maximum on the position's profitability.\r\n~~~\r\n(pnl-range \r\n [:btc-usd (range 6000 11000 100)]\r\n (buy 2 :btc-usd 7000)\r\n (write-call :btc-usd {:n 2 :price 3050 :strike 10000}))\r\n~~~\r\n\r\n## Custom Plots\r\n\r\nYou can use the `plot` function to tune your plots at a more granular level.\r\n~~~\r\n(plot\r\n (range 5000 13000 100)\r\n {\"Inverse Short Position\" \r\n  (fn [x] \r\n    (let [entry-price 9000\r\n          price-change (- entry-price x)\r\n          pos-size (/ (* entry-price -1) x)]\r\n      (* pos-size price-change -1)))\r\n  \"Normal Short Position\"\r\n  (fn [x]\r\n    (let [entry-price 9000]\r\n      (- entry-price x)))}\r\n {:x \"BTCUSD Price\"\r\n  :y \"USD Profit\"})\r\n~~~\r\n\r\n"].join('');
}
})());
}
trade_repl.core.main = (function trade_repl$core$main(){
reagent.core.render.call(null,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [trade_repl.editor.editor,trade_repl.core.editor_text,(function (p1__26839_SHARP_){
return cljs.core.reset_BANG_.call(null,trade_repl.core.editor_text,p1__26839_SHARP_);
})], null),document.getElementById("editor"));

reagent.core.render.call(null,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [trade_repl.display.render,trade_repl.core.editor_text,trade_repl.dsl.dsl_eval_factory], null),document.getElementById("display"));

var loading = document.getElementById("loading");
return loading.parentNode.removeChild(loading);
});
goog.exportSymbol('trade_repl.core.main', trade_repl.core.main);
trade_repl.core.on_js_reload = (function trade_repl$core$on_js_reload(){
return trade_repl.core.main.call(null);
});
